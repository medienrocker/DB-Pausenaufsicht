</div>
<div class="szy_wrapper">
    <table id="pausenaufsicht-table">
        <thead>
            <tr>
                <th>Pausen</th>
                <th>Orte</th>
                <th>Mo</th>
                <th>Di</th>
                <th>Mi</th>
                <th>Do</th>
                <th>Fr</th>
            </tr>
        </thead>
        <tbody>
            <!-- Table body will be dynamically generated by JavaScript -->
        </tbody>
    </table>
</div>


<script>
    // Wait for the DOM to be fully loaded
    document.addEventListener('DOMContentLoaded', function () {

        // Extract data from slot spans
        const slotData = {};
        const slots = document.querySelectorAll('#moodle-fields-container span[class^="slot"]');

        slots.forEach(slot => {
            const slotNumber = slot.className;
            const anchor = slot.querySelector('a');
            if (anchor) {
                const value = anchor.textContent.trim();
                const href = anchor.getAttribute('href');
                if (value !== '') {
                    if (!slotData[slotNumber]) {
                        slotData[slotNumber] = [];
                    }
                    slotData[slotNumber].push({ value, href });
                }
            }
        });

        // Sort the slotData object by keys (slot numbers)
        const sortedSlotData = Object.fromEntries(
            Object.entries(slotData).sort(([a], [b]) => a.localeCompare(b))
        );

        // 
        setPerPageValue(300);

        // Generate the table
        generatePausenaufsichtTable(sortedSlotData);
    });

    function generatePausenaufsichtTable(slotData) {
        // Find the 'Eintrag hinzufügen' button and extract its href
        const addEntryButton = document.querySelector('a[role="button"]:not([href="#"])');
        const addEntryHref = addEntryButton ? addEntryButton.getAttribute('href') : '#';

        const tableBody = document.querySelector('#pausenaufsicht-table tbody');

        tableBody.innerHTML = ''; // Clear existing content

        let slotIndex = 1;

        // Iterate through the maximum number of pauses
        for (let pauseIndex = 0; pauseIndex < MAX_PAUSES; pauseIndex++) {
            const pauseEntries = new Map(); // Track entries for each day in this pause

            ORTE.forEach((ort, ortIndex) => {
                const row = document.createElement('tr');

                // Add a class to the first row of each pause group
                if (ortIndex === 0) {
                    row.classList.add('pause-group-start');
                }

                // Pause cell (only for the first row of each pause)
                if (ortIndex === 0) {
                    const pauseCell = document.createElement('td');
                    pauseCell.textContent = `${pauseIndex + 1}. Pause`;
                    pauseCell.className = 'pause-cell';
                    pauseCell.rowSpan = ORTE.length;
                    row.appendChild(pauseCell);
                }

                // Orte cell
                const orteCell = document.createElement('td');
                orteCell.textContent = ort.name;
                orteCell.className = 'orte-cell';
                row.appendChild(orteCell);

                // Weekday cells
                WEEKDAYS.forEach(day => {
                    const dayCell = document.createElement('td');
                    dayCell.className = 'content-cell';
                    const container = document.createElement('div');
                    container.className = 'subcell-container';

                    const slotKey = `slot${String(slotIndex).padStart(3, '0')}`;
                    const entries = slotData[slotKey] || [];

                    if (!pauseEntries.has(day.name)) {
                        pauseEntries.set(day.name, new Set());
                    }
                    const dayEntries = pauseEntries.get(day.name);

                    if (pauseIndex < day.pauses) {
                        // Determine the overall filling state for this cell
                        let fillingState;
                        if (entries.length < ort.teachersNeeded) {
                            fillingState = 'almostFilled';
                        } else if (entries.length === ort.teachersNeeded) {
                            fillingState = 'filled';
                        } else {
                            fillingState = 'overfilled';
                        }

                        for (let j = 0; j < Math.max(entries.length, ort.teachersNeeded); j++) {
                            const subcell = document.createElement('a');
                            subcell.className = 'subcell-item';
                            subcell.style.display = 'flex';

                            if (j < entries.length) {
                                const entry = entries[j];
                                const span = document.createElement('span');
                                const name = entry.value.toLowerCase();
                                span.textContent = entry.value;
                                subcell.appendChild(span);
                                subcell.href = entry.href;
                                subcell.title = "Eintrag bearbeiten";

                                // Apply the filling state class
                                subcell.classList.add(fillingState);

                                // Check for conflicts
                                if (dayEntries.has(name)) {
                                    subcell.classList.add('conflict');
                                } else {
                                    dayEntries.add(name);
                                }
                            } else {
                                // Empty subcell for unfilled positions
                                subcell.href = `${addEntryHref}&slotIndex=${slotIndex}`;
                                subcell.title = "Aufsicht fehlt noch!\nKlicken zum Hinzufügen";
                                subcell.classList.add('almostFilled');

                                console.log(subcell.hre);
                            }

                            container.appendChild(subcell);
                        }
                    } else {
                        // Create disabled cell for non-existent pauses
                        const subcell = document.createElement('div');
                        subcell.className = 'subcell-item disabled';
                        subcell.textContent = '-';
                        subcell.title = "Keine Aufsicht nötig";
                        container.appendChild(subcell);
                    }

                    dayCell.appendChild(container);
                    row.appendChild(dayCell);
                    slotIndex++;
                });

                tableBody.appendChild(row);
            });
        }
    }

    function setPerPageValue(entriesPerPage) {
        // Get the select element by its ID
        const selectElement = document.getElementById('pref_perpage');
        console.log("Einträge pro Seite am Anfang: " + selectElement.value);

        // Set the value to entriesPerPage
        selectElement.value = entriesPerPage;
        console.log("Einträge pro Seite am Ende: " + selectElement.value);

        // Check if the value was set successfully
        if (selectElement.value !== entriesPerPage) {
            console.warn("Unable to set value to 300. This option might not exist in the select element.");

            // Optionally, you can add a new option if it doesn't exist
            if (!Array.from(selectElement.options).some(option => option.value === entriesPerPage)) {
                const newOption = new Option(entriesPerPage, entriesPerPage);
                selectElement.add(newOption);
                selectElement.value = entriesPerPage;
            }
        }
    }
</script>